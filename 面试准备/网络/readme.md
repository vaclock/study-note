[toc]
## 五层网络模型
从上到下分别为：
应用层：跟具体应用相关的协议                HTTP(必须是客户端到服务器) FTP（文件共享） DNS SMTP（发邮件） POP3（收邮件）
传输层：保证消息的可靠传输                  TCP（消息准确, HTTP基于TCP） UDP（消息可能会丢包）
网络层：在互联网找到对方                    IP 路由器（设备）
数据链路层：在一个子网（局域网）中找到对方？    MAC 交换机（设备）
物理层：上面给我的东西如何用信号表示并传输？   光纤 双绞线 同轴电缆 集线器


## 常见的请求方式
本质：本质就是请求行中的一个单词 它向服务器描述了客户端发出请求的动作类型
在HTTP中 不同的请求方法只是包含了不同的语义，但服务器和客户端约定俗成的一些行为造成了他们的区别

**HTTPS常见请求方法有哪些**
- GET 表示向服务器获取资源 请求数据在请求行中(浏览器规定大概是4KB--其他环境比如node环境无限制) 无须请求体(写了浏览器中fetch会报错、node环境会忽视请求体)
- POST 表示向服务器提交信息 通常用于产生新的数据或者获取登录信息 请求数据一般在请求体中(当然也可以在请求体中,请求体提交数据浏览器无限制)
- PUT 表示希望服务器修改数据 业务数据在请求体中
- DELETE 删除
- OPTIONS 发生跨域时预检请求 向服务端提交跨域申请
- TRACE 用于测试与诊断
- CONNECT 用于建立连接管道 用于代理 网页中几乎很少

**GET与POST的区别**
- GET在浏览器无法添加请求体,会报错 在node环境则无效
- GET请求的请求行参数大小有限制 POST请求体浏览器无限制
- GET请求只支持ASCII编码,如果有中文 需要转码(现在浏览器会自动编码)
- 大概率GET请求传递的参数都在path中 能够通过分享地址完整的重现页面 但是也暴露了数据 所以敏感数据不应该使用GET请求 起码请求参数不应该放到path中
- 刷新页面时 如果是POST请求 浏览器会提示用户是否重现提交 如果是GET请求 则不会
- GET请求可以被收藏浏览器书签 POST请求则不行

## cookie

由于http协议是无状态的 为了在客户端不需要用户每次都输入身份认证 所以可以用cookie来存储用户信息
> 在html5之前是没有localStorage的 不然localStorage也可以实现

在后续请求服务端的时候 请求中带着cookie即可

### cookie的构成
- key: 键
- value: 值
- domain: 生效的域
- path: 请求path 比如/login请求 (该参数可选)
- secure: 如果是true 则请求协议必须是https 否则不会发送该cookie
- expire: 过期时间 时间戳
- max-age: 设置cookie的相对有效期。expire和max-age通常仅设置一个即可。比如设置max-age为1000，浏览器在添加cookie时，会自动设置它的expire为当前时间加上1000秒，作为过期时间。
- http-only: 设置cookie是否仅用于传输 如果为true 则代表无法通过js获取 只会在请求时携带 可以防止XSS

具体如何将cookie加入到请求中呢?
- 浏览器会将符合条件的cookie 自动添加到请求中

### 如何设置cookie
- 服务端设置cookie 在响应体中依次添加cookie 可设置多个cookie 浏览器接受之后会自动写入并覆盖path&domain相同的cookie
  每个cookie的格式为: 键=值; path=?; domain=?; expire=?; max-age=?; secure; httponly
```shell
set-cookie: cookie1
set-cookie: cookie2
set-cookie: cookie3
```

- 客户端设置cookie
```js
document.cookie = "键=值; path=?; domain=?; expire=?; max-age=?; secure";
```
## storage
localStorage、sessionStorage、cookie区别？
三者都可以存储本地数据
cookie的兼容性最佳 所有浏览器都支持 浏览器也对cookie有一些默认行为 比如服务端的响应体中有```set-cookie:key=value;```字段时 浏览器会自动设置cookie 每次客户端发生请求时 浏览器也会自动携带合法的cookie 浏览器对cookie的限制大小大概是4KB 正因为这些默认行为 使得网站攻击者可以使用cookie进行攻击

html5新增的sessionStorage和localStorage 区别是前者只存在于会话阶段 会话结束 则sessionStorage的数据失效 localStorage用于持续的存储数据 如果用户不删除 则不会失效 浏览器针对storage没有默认行为 使得相对cookie比较安全 读取数据 存储数据的工作交给了js代码 同时storage大小限制一般在5MB 而且storage只和domain有关联 cookie和domain和path有关联

## 加密
### 对称加密
- 明文通过密钥 得到密文
- 密文通过相同的密钥得到明文
常见的有AES DES
优点: 加密 解密速度快 适合大数据量加密
缺点: 在网络中需要分发密钥 增加了密钥被窃取的风险

### 非对称加密
- 明文通过公钥得到密文
- 密文通过私钥得到明文
常见的有RSA DSA
- 优点: 安全(仅有一方可以解密 私钥是永远不会在网络进行传输的 一般存储在服务器)--当然服务器如果被攻击了就没法了
- 缺点: 仅有一方可以解密

### 摘要/哈希/散列
- 明文通过算法得到密文 (可以用于将用户密码存储成md5加密之后的密码, 好处是服务器万一被攻击 攻击者也不知道密码是啥 用户密码不应该被除了用户之外的任何人知道)
常见算法: MD4 MD5
优点: 密文占用空间小(定长的短字符串) 难以被破解
缺点: 目前无法解密


## JWT(JSON-Web-Token)
- 用户登录的流程: 使用cookie自动实现 请求体中```set-cookie: key=value;``` 通过浏览器每次发起请求自动携带cookie 服务端使用cookie进行验证

- 问题: 非浏览器环境怎么办? 如何防止令牌被伪造?

- jwt可以出现在任何客户端与服务端约定好的地方
``` shell
HTTP/1.1 200 ok

...
set-cookie: token=jwt令牌;
...

...
authorization: bearer jwt令牌;
...

...
body: {
  token: jwt令牌
}
...
```

客户端拿到jwt令牌之后 可以存储到storage、cookie中

### jwt的组成(三部分)
- header: 令牌头, 令牌类型和签名算法
- payload: 令牌负荷, 保存主体信息 如用户信息
- signature: 令牌签名, 按照头部和负荷进行签名 该签名的作用是保证令牌不被伪造


## 同源策略
- 浏览器的安全策略
源: 协议 + 主机 + 端口号

## 跨域
- 在浏览器中由于同源策略导致的

## 文件上传
使用input输入框提供的能力 监听input输入框的change事件 
```js
// 上传文件
const formData = new FormData();
formData.append('file', inputDom.files[0]); // 添加一个键值对
const resp = await fetch('http://localhost:8000/api/upload', {
  method: 'POST',
  body: formData,
})
```

## 输入url之后

1. 浏览器根据用户输入自动补充协议、端口号或者其他内容
2. 浏览器会非ASCII码进行转码
3. 浏览器查找是否浏览器中有缓存 若有缓存 直接返回缓存 不再发起新的请求
7. **浏览器进行dns 得到域名对应ip**
9. **浏览器建立TCP三次握手连接**
10. 浏览器根据协议类型判断是否进行TLS握手(https) **用于生成加密通道 此时 会判断是否使用http2**
11. 浏览器决定将哪些cookie带入请求头中
12. 浏览器填充请求头 携带cookie 发起一次GET请求
13. 此时进入服务端处理流程 服务端根据用户请求返回对应的结果
14. 浏览器根据服务端的Connection以及协议的版本 用来判断是否保留TCP连接
15. 浏览器根据服务端的响应码来决定如何处理本次请求
16. 浏览器收到服务端发送的http报文 根据content-type进行不同的处理
17. 浏览器根据响应头中的cookie 自动设置cookie
18. 如果是html页面 浏览器渲染主线程会解析html 开始渲染 将html解析为Dom树 将css解析为cssom树 **同时**将dom树和cssom树合并成一个渲染树(rendering tree) 浏览器通过渲染树计算各个元素的位置和大小 进行重排(reflow) 完成重排之后 将计算结果发送给GPU 进行渲染
19. dom树完成之后 浏览器出发DomContentLoaded事件 整个页面加载完成之后 触发load事件

## 文件下载

## session

## HTTP缓存
在一个C/S结构中 最基本的缓存分为两种
- 客户端缓存
- 服务器缓存

此次仅讨论客户端缓存
客户端在向服务端发起请求之后 服务器在响应头中约定俗称的加入相应字段 表示此条请求希望浏览器能够缓存 并设置一个缓存过期时间
- 服务器的响应头(此处响应码为200 一般在响应体中包含了所有数据)
```shell
Cache-Control: max-age=3600 # 3600单位是s
ETag: # 资源编号 无含义
Date: Thu, 30 Apr 2023 11:29:22 GMT # 请求响应时刻
Last-Modified: Thu, 30 Apr 2023 11:29:22 GMT # 这个资源上一次修改的时间是xxx格林威治时间
```
> 浏览器看到服务器的某条响应头中包含这些信息之后
- 浏览器将这次请求得到的响应体缓存道本地文件中
- 浏览器标记这次请求的请求头和路径(需要区别具体是哪个请求被缓存了)
- 标记响应头里的这些信息

- 来自客户端的缓存指令(协商缓存)
客户端收到一个请求时
1. 判断缓存中是否有本次的请求方法和路径
2. 如果有 判断是否在有效期内 如果在有效期内 则使用缓存
3. 如果无法判断或者已经过有效期 则发起一个请求 请求头中带有`If-Modified-Since`(last-modified)和`If-None-Match`(etag资源唯一标识) 如果服务端返回一个304的响应码 则浏览器可以继续使用缓存 如果服务端判断资源已经更新 则返回200响应码和新的的数据以及响应的缓存响应头

## TCP协议

### 分段发送
完整数据 -> 按照字节编号 -> 发送数据报

### 可靠传输
在TCP协议中 任何时候 任何一方都可以主动发送数据给另一方
TCP协议要求: 接收方收到数据后 必须对数据报进行**确认**
- seq: 表示这次数据报的序号(比如1)
- ACK: 表示这次数据报是一个**确认数据报**
- ack: 表示下一次期望收到的数据报序号(ack=seq+1 表示seq+1之前的都收到了)
发送方如果长时间没有收到ACK确认数据报(ACK=1) 则会进行重发

### 连接的建立(三次握手)
TCP协议要实现数据的收发 必须先建立连接

- 连接的建立其实就是数据收发双方开辟一块内存 内存中主要是数据缓冲区和一些变量

- SYN=1: 同步 表示请求建立连接
- seq=x: 发送的数据报序号
- ACK=1: 确认数据报
- ack=x+1: 确认数据报中的确认完全收到的数据序号

连接的建立有三个过程 **tcp协议本身不一定是客户端主动发送** 以下数据在分段数据报文头里
send(发送方)、 receiver(接受方)
- send --(**SYN=1**,seq=x)-> receiver :请求建立连接
- send <--(**SYN=1**,seq=y,ACK=1,ack=x+1)-> receiver  :收到请求 回复确认
- send --(**ACK=1**,ack=y+1,seq=x+1)-> receiver   :收到确认
- 开始传输数据

### 连接的销毁

- FIN=1: 表示请求连接销毁(Finished)
- seq=u: 发送的数据报序号是u (Sequence)
- ACK=1: 确认数据报(Acknowledgement)
- ack=u+1: 确认数据报中的确认完全收到的数据序号

连接的销毁有四个过程
send(发送方)、 receiver(接受方)
- 传输数据完成
- send --(**FIN=1**,seq=u)-> receiver           :传输完成请求销毁连接
- send <--(**ACK=1**,seq=v,ack=u+1)- receiver   :收到传输完成 连接销毁请求的信息
- send <--(**FIN=1**,seq=w,|ACK=1,ack=u+1)- receiver :传输完成 销毁连接确认
- send --(**ACK=1**,ack=w+1,seq=u+1)-> receiver   :确认收到销毁
- send:(TIME WAIT)等待2MSL(数据一个来回) 等待的原因是担心服务未正常收到 此时服务器会重发销毁连接确认消息

### HTTP和TCP的关系
- http: 应用层协议 规定了服务端与客户端之前的消息格式
- tcp: http使用tcp完成了消息的可靠传输
具体使用tcp协议时:
- 客户端发送消息给服务端叫做请求 服务端发送给客户端叫做响应
- 使用了http协议的服务端不能主动发消息给客户端(即使tcp协议没有这个限制), 只对请求做出响应
- 每次http请求-响应 都要发生tcp协议三次握手 然后进行请求-响应后 进行四次挥手 这就导致了每次请求-响应都是独立的 无法保持状态

为什么是无状态的呢?(也就是为什么请求完成之后要马上断开连接呢?)
- 为了节约服务器资源 因为连接的建立是需要服务器开辟一块内存的(牺牲时间换空间)

## web攻击
### CSRF攻击
跨站请求伪造 cross site request forgery
原理: 攻击者利用了用户的身份信息(cookie保存用户身份信息) 执行了用户非本意的操作

防御:
- 不将用户身份信息放到cookie中
- 


### XSS攻击

## 网络性能优化
列举网络优化的方法
- 优化打包体积: 利用一些工具、混淆最终打包代码,减少包体积
- 多目标打包: 利用一些打包插件 针对不同的浏览器打包出不同的兼容性版本(`--modern`) 这样每个版本中的兼容性代码就会减少 从而减少包体积
- 压缩: gzip压缩
- CDN: 多服务器 根据用户就近选择服务器 一般托管静态资源
- 缓存: http缓存
- http2: 开启多路复用
- 雪碧图: 对于不使用http2的情况下 可以将多个图片融合成雪碧图(多次请求需要建立连接)
- defer, async: 可以让页面尽早加载js
- prefetch, preload:
  - prefetch: 可以让页面在空闲时间预先下载其他页面可能会用到的资源
  - preload: 可以让页面预先下载本页面可能会用到的资源
- 多个静态资源域: 对于不使用http2的情况, 将相对独立的静态资源部署到不同域名 可以让浏览器开启多个tcp连接并行下载



## 断点续传

## 域名和DNS

## SSL TLS HTTPS

## HTTP各版本差异
HTTP协议: 运行在TCP上, 指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应的一种协议

### HTTP常见响应码

## WebSocket
实时场景: 股票k线图、聊天、警报、重要通知、抢购、抢票
特点: 实时性
- 短轮询
- 长轮询

1. websocket协议是什么?
websocket是基于tcp协议之上 利用了tcp全双工通信的能力
使用websocket, 会经历两个阶段: 握手阶段, 通信阶段

但是维护tcp会浪费资源

